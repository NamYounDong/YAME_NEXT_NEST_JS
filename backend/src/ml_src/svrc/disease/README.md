## 0) 목표 정리 (우리가 만들 것)

### 📥 입력
- 사용자의 자유서술 프롬프트 (예: "어제부터 몸이 으슬으슬하고 열이 나요")

### 📤 출력
- **추출된 증상 후보**: 정규화된 표준 증상 ID/명칭, 신뢰도
- **병명 후보 Top-K**: 근거 증상, 점수, 간단 설명

### 🎯 핵심 원리
- **오프라인(ETL)**: 질병/증상 지식그래프 + 임베딩 캐시를 꾸준히 구축/정제
- **온라인(실시간)**: NER/멀티라벨 분류 + 임베딩 근접탐색 + 그래프 가중합 랭킹으로 즉시 추론
- **비LLM 중심**: SBERT 계열 임베딩(문장 임베딩), KoBERT/한국어 BERT 기반 증상 추출 분류기 등

## 1) 런타임(사용자 프롬프트 처리) 흐름

### 1-1. 📝 텍스트 정리(전처리)
- 소문자화·공백 정리·이모지 제거
- 한국어 형태소 보조(선택: Mecab/Okt)
- **예시**: "어제부터 몸이 으슬으슬하고 열이 나요" → "몸이 으슬으슬하다" + "발열" 후보 표현 포착

### 1-2. 🔍 증상 후보 추출 (NLP / NER + 멀티라벨 분류)

#### 방식 A (간단 시작)
- **키워드 사전**: `SYMPTOM_MASTER.CANONICAL` + `ALIASES`에서 가져온 어휘를 부분일치/형태소 보정으로 매칭
- **오탈자 보정**: 편집거리(Levenshtein) ≤ 1~2 허용

#### 방식 B (권장, 비LLM 모델)
- **멀티라벨 분류기**: KoBERT/KcBERT 기반으로 문장→증상 확률 벡터 예측
- **임계값**: 상위 p≥τ_sym(예: 0.35)만 후보 채택
- **결과 예시**: `[("오한", 0.78), ("발열", 0.73)]`

### 1-3. 🎯 캐노니컬라이즈(정규화) — 임베딩 근접탐색
- **방법**: SBERT 임베딩으로 문구→표준 증상 최근접 탐색(코사인 유사도)
- **임계값 2단계**:
  - `s ≥ τ_auto(0.76)`: 자동 승인
  - `τ_pending ≤ s < τ_auto`: 보류(후속 검수)
- **장점**: 하드코딩 맵 대신 임베딩+사전으로 자동 정규화
- **결과 예시**: `"몸이 으슬으슬하다" → (표준증상 "오한", 0.82, auto)`

### 1-4. 🏥 병명 후보 추론 (증상→질병)

#### 하이브리드 스코어링(실무적이고 튼튼)
- **그래프 가중합**: `DISEASE_SYMPTOM`의 weight 합
  - `s_graph(d) = Σ_i w(d, symptom_i)`
- **의미 유사도**: 사용자 프롬프트 임베딩 vs `disease_embedding_item.TEXT_SOURCE` 임베딩 코사인
  - `s_sem(d) = cos(E(prompt), E(disease_d))`
- **혼합 점수**: `S(d) = α·s_graph + (1−α)·s_sem` (α≈0.6~0.8부터 시작)
- **결과**: Top-K(예: 5~10개) 반환 + 근거 설명

#### 📊 작은 예시
```
입력: "몸이 으슬으슬하고 열이 나요"
증상 후보: [오한(0.82, auto), 발열(0.77, auto)]
그래프 점수 상위: 독감, 감기, 급성편도염...
의미 유사도 상위: 독감, 인플루엔자(동의어), 감기...

혼합 Top-3:
  1) 독감(0.86) — 근거: 오한·발열 w=1.0+0.8, 본문 유사도↑
  2) 감기(0.79) — 근거: 발열 w=0.6, 본문 유사도 중간
  3) 급성편도염(0.65) — 근거: 발열만 일치
```

## 2) 오프라인(ETL) 파이프라인 — 왜 필요한가 & 무엇을 하냐

### 2-1. 📥 수집/파싱 (AMC/위키) → DISEASE_MASTER
- **작업**: 페이지 원문을 안정적으로 저장(`SOURCE_PAGE_FETCH`)하고, 질병명/설명/증상 원문을 추출해 `DISEASE_MASTER`에 업서트
- **이유**: 질병-증상 그래프와 임베딩의 재현 가능한 소스가 필요

### 2-2. 🔄 증상 정규화(M:N) → SYMPTOM_MASTER / DISEASE_SYMPTOM
- **작업**: 파싱된 원문 증상을 표준 증상으로 정규화하여 M:N 연결
- **이유**: 그래프 기반 추천(가중합), DUR/OTC 필터, 통계 모두 ID 기반 조인이 가장 쉽고 빠름

### 2-3. 🧠 의미 검색 준비 → disease_embedding_item, SYMPTOM_EMBEDDING
- **작업**: 
  - 질병 텍스트(이름+증상목록+요약) 임베딩 저장 → 의미검색/혼합 점수에 사용
  - 표준 증상 임베딩 캐시 → 정규화와 런타임 근접탐색 가속
- **이유**: 사용자 발화는 표현이 다양함("목이 간질간질"↔"인후 자극"); 임베딩이 이를 흡수

### 2-4. 📝 별칭 누적/검수 → SYMPTOM_ALIAS_MAP, SYMPTOM_PHRASE_LOG
- **작업**: 
  - 런타임에서 본 새 표현을 로그(등장 빈도), 임계값에 따라 별칭 후보로 기록
  - 관리자는 pending을 승인/반려 → 사전 품질이 매일 좋아짐
- **이유**: 하드코딩 없이 데이터가 사전을 키움. 추후 미세조정 학습 데이터로도 활용

## 3) 사용 기술(비LLM 중심)과 "왜 이게 실무적?"

### 🔍 증상 추출
- **기술**: KoBERT/KcBERT 등 한국어 BERT 기반 멀티라벨 분류기
- **방식**: 각 증상 클래스에 확률 출력 → 임계값 기반 선택
- **장점**: 사전이 못 잡는 표현(은어/오탈자)도 모델이 포착

### 🎯 캐노니컬라이즈
- **기술**: 문장 임베딩(SBERT/다국어 USE) + 코사인/ANN 인덱스
- **장점**: 동의어/표현 변화에 강건, LLM 없이도 고품질

### 🏆 질병 랭킹
- **기술**: 그래프 가중합 + 임베딩 혼합
- **장점**: 그래프는 "지식 기반"의 안정성, 임베딩은 "자연어 다양성 흡수" → 현업에서 가장 튼튼한 조합

### 🔄 검수/루프
- **방식**: 승인 데이터가 쌓이면 SBERT 미세조정으로 점수↑
- **장점**: 운영 난이도 낮음(주기적 재학습·재임베딩만 수행)

## 4) 품질/성능 어떻게 다듬나?

### 4-1. ⚙️ 임계값/가중치 기본값
- **증상 자동승인**: τ_auto ≈ 0.76
- **증상 보류**: τ_pending ≈ 0.62
- **혼합 가중치**: α(그래프 비중) ≈ 0.7
- **Top-K**: 5~10

### 4-2. 📊 평가 지표(간단/실전)
- **증상 정규화 정확도**: 승인/반려 대비 자동승인 적중률
- **질병 후보 Hit@K**: 정답이 Top-K 안에 들어가는 비율
- **사용자 피드백**: "도움됨" 비율, 반려 사유 로그

### 4-3. 🚀 성능
- **초기**: 브루트포스 코사인으로 충분(수천~수만 단위)
- **확장**: 커지면 FAISS(IVF, HNSW)로 전환
- **갱신**: 임베딩/지표는 배치 갱신(예: 매일 새벽)

## 5) 간단 예시(소형 데이터로 머릿속 시뮬레이션)

### (a) 📋 테이블 스냅샷

#### SYMPTOM_MASTER
```
101: "오한", 102: "발열", 103: "두통", 104: "기침" …
```

#### DISEASE_MASTER (요약)
```
독감 / 감기 / 급성편도염 …
```

#### DISEASE_SYMPTOM
```
독감: (오한:1.0, 발열:1.0, 두통:0.6, 기침:0.4)
감기: (기침:1.0, 콧물:1.0, 발열:0.5) …
```

### (b) 🔄 입력 → 출력
```
입력: "몸이 으슬으슬하고 열이 나요"
증상 추출: ["오한"(0.82), "발열"(0.77)]
질병 랭킹(혼합):
  독감 0.86, 감기 0.79, 급성편도염 0.65

반환:
  1) 독감 — 근거: 오한·발열, 유사도↑
  2) 감기 — 근거: 발열, 유사도 중간
```

## 6) 앞으로 이 구조가 어떻게 쓰이냐?

### 💊 상비약 추천 연결
- **흐름**: 질병 후보 → OTC 카테고리 후보 → (나중 단계) DUR 주의/금기로 필터
- **개인화**: 사용자 연령/임신/복용 성분을 곱해 개인화 필터링

### 🦠 감염병 징후 추적
- **데이터**: `SYMPTOM_PHRASE_LOG` + 지역/시간 → 증상 히트맵
- **감지**: "오한+발열" 급증 구간 감지 → 보건 지표

### 🔄 모델 개선 루프
- **데이터 수집**: 검수 승인된 별칭·오류 피드백 → 미세조정 데이터셋
- **개선 사이클**: 재학습 → 재임베딩 → 품질 상승의 선순환

### 📋 설명가능성
- **투명성**: 결과마다 "어떤 증상/문장"이 기여했는지 로그/리포트에 남김 → 운영 신뢰성

## 7) 구현 단계 체크리스트(코드 직전)

### ✅ 체크리스트
- [ ] **DDL 반영**: 이미 캔버스에 게시한 테이블 세트
- [ ] **파서 보강**: AMC/위키 섹션 안정화, 실패 로그/재시도
- [ ] **증상 멀티라벨 분류기**: 초기엔 사전+편집거리, 이어서 KoBERT 기반 이중화
- [ ] **임베딩 파이프라인**: `disease_embedding_item`, `SYMPTOM_EMBEDDING` 생성
- [ ] **혼합 랭킹**: 그래프 w합 + 의미 유사도
- [ ] **검수 플로우**: pending 승인→사전 강화, 자동 임계값 튜닝
- [ ] **모니터링 SQL/대시보드**: 성공률, Hit@K, 자동승인 적중률